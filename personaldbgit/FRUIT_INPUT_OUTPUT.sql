--SEQUENCE를 PRIMARY KEY로
--5종류 상품의 입출력을 관리하는 프로그램을
--TRIGGER를 이용하여 만들자.

SELECT * FROM PRODUCT_FRUIT;
SELECT * FROM PRODUCT_INOUT;
SELECT * FROM PRODUCT_TIME;
DROP TABLE PRODUCT_TIME;
DROP TABLE PRODUCT_INOUT;
DROP TABLE PRODUCT_FRUIT;

DESC  PRODUCT_TIME;

CREATE TABLE PRODUCT_FRUIT(
  PRODUCT_NO NUMBER PRIMARY KEY
, PRODUCT_NAME VARCHAR2(30) CONSTRAINT NN_PRODUCT_NAME NOT NULL
, PRODUCT_NATIVE_HABITAT VARCHAR2(30) CONSTRAINT NN_PRODUCT_NATIVE_HABITAT NOT NULL
, PRODUCT_PRICE NUMBER CONSTRAINT NN_PRODUCT_PRICE NOT NULL
, PRODUCT_STOCK NUMBER DEFAULT 0 CONSTRAINT NN_PRODUCT_STOCK NOT NULL
, CONSTRAINT CK_PRODUCT_PRICE CHECK(PRODUCT_PRICE >= 0)
, CONSTRAINT CK_PRODUCT_STOCK CHECK(PRODUCT_STOCK >= 0)  
);
COMMENT ON COLUMN PRODUCT_FRUIT.PRODUCT_NO IS '상품 번호';
COMMENT ON COLUMN PRODUCT_FRUIT.PRODUCT_NAME IS '상품 이름';
COMMENT ON COLUMN PRODUCT_FRUIT.PRODUCT_NATIVE_HABITAT IS '상품 원산지';
COMMENT ON COLUMN PRODUCT_FRUIT.PRODUCT_PRICE IS '상품 가격';
COMMENT ON COLUMN PRODUCT_FRUIT.PRODUCT_STOCK IS '상품 재고';

CREATE TABLE PRODUCT_INOUT(
  IO_PRODUCT_NUMBER NUMBER  
, IO_PRODUCT_NO NUMBER
, IO_PRODUCT_AMOUNT NUMBER
, IO_PRODUCT_STATUS VARCHAR2(30)
, CONSTRAINT PK_IO_PRODUCT_NUMBER PRIMARY KEY (IO_PRODUCT_NUMBER) 
, CONSTRAINT FK_IO_PRODUCT_NO FOREIGN KEY (IO_PRODUCT_NO)
                              REFERENCES PRODUCT_FRUIT(PRODUCT_NO)
, CONSTRAINT CK_IO_PRODUCT_AMOUNT CHECK(IO_PRODUCT_AMOUNT >0)
, CONSTRAINT CK_IO_PRODUCT_STATUS CHECK(IO_PRODUCT_STATUS IN ('입고' , '출고'))
);

COMMENT ON COLUMN PRODUCT_INOUT.IO_PRODUCT_NUMBER IS '입출고기록';
COMMENT ON COLUMN PRODUCT_INOUT.IO_PRODUCT_NO IS '상품 번호';
COMMENT ON COLUMN PRODUCT_INOUT.IO_PRODUCT_AMOUNT IS '수량';
COMMENT ON COLUMN PRODUCT_INOUT.IO_PRODUCT_STATUS IS '입출고';

CREATE TABLE PRODUCT_TIME(
  PRODUCT_TIME_NUMBER NUMBER
, PRODUCT_TIME_NO NUMBER  
, PRODUCT_TIME_RELEASE_DATE DATE DEFAULT SYSDATE CONSTRAINT NN_DETAIL_PRODUCT_RELEASE_DATE NOT NULL
, PRODUCT_TIME_SHELF_LIFE_DATE DATE DEFAULT (SYSDATE+7) CONSTRAINT NN_DETAIL_PRODUCT_SHELF_LIFE_DATE NOT NULL
, CONSTRAINT PK_PRODUCT_TIME_NUMBER PRIMARY KEY (PRODUCT_TIME_NUMBER)
, CONSTRAINT FK_PRODUCT_TIME_NO FOREIGN KEY (PRODUCT_TIME_NO) 
                                REFERENCES PRODUCT_INOUT(IO_PRODUCT_NUMBER)
);
COMMENT ON COLUMN PRODUCT_TIME.PRODUCT_TIME_NUMBER IS '재고기한관리번호';
COMMENT ON COLUMN PRODUCT_TIME.PRODUCT_TIME_NO IS '입출고 상품 번호';
COMMENT ON COLUMN PRODUCT_TIME.PRODUCT_TIME_RELEASE_DATE IS '제조시간';
COMMENT ON COLUMN PRODUCT_TIME.PRODUCT_TIME_SHELF_LIFE_DATE IS '유통기간';


DROP SEQUENCE SEQ_FRUIT;
DROP SEQUENCE SEQ_IO;
DROP SEQUENCE SEQ_TIME;

CREATE SEQUENCE SEQ_FRUIT
NOCACHE;
CREATE SEQUENCE SEQ_IO
NOCACHE;
CREATE SEQUENCE SEQ_TIME
NOCACHE;

DROP TRIGGER TRP_PRODUCT_INOUT;
DROP TRIGGER TRG_PRODUCT_TIME_NUMBER;
DROP TRIGGER TRG_PRODUCT_TIME_NO;

CREATE OR REPLACE TRIGGER TRG_PRODUCT_INOUT AFTER
  INSERT ON PRODUCT_INOUT
  FOR EACH ROW
BEGIN 
  IF :NEW.IO_PRODUCT_STATUS = '입고'
    THEN
      UPDATE PRODUCT_FRUIT A
         SET A.PRODUCT_STOCK = A.PRODUCT_STOCK + :NEW.IO_PRODUCT_AMOUNT
       WHERE A.PRODUCT_NO = :NEW.IO_PRODUCT_NO;
  END IF;
  IF :NEW.IO_PRODUCT_STATUS = '출고'
    THEN
      UPDATE PRODUCT_FRUIT A
         SET A.PRODUCT_STOCK = A.PRODUCT_STOCK - :NEW.IO_PRODUCT_AMOUNT
       WHERE A.PRODUCT_NO = :NEW.IO_PRODUCT_NO;
  END IF;
END;
/

--CREATE OR REPLACE TRIGGER TRG_PRODUCT_TIME_NO AFTER
--  INSERT ON PRODUCT_INOUT
--  FOR EACH ROW
--BEGIN
--  IF :NEW.IO_PRODUCT_STATUS = '입고'
--    THEN
--      INSERT 
--        INTO PRODUCT_TIME A
--      (
--        A.PRODUCT_TIME_NO
--      , A.PRODUCT_TIME_RELEASE_DATE
--      , A.PRODUCT_TIME_SHELF_LIFE_DATE
--      )
--      VALUES 
--      (
--        IO_PRODUCT_NO
--      , DEFAULT
--      , DEFAULT
--      );  
--  END IF;
--END;
--/

--CREATE OR REPLACE TRIGGER TRG_PRODUCT_TIME_NUMBER BEFORE
--  INSERT ON PRODUCT_TIME
--  FOR EACH ROW
--BEGIN
--  SELECT SEQ_TIME.NEXTVAL 
--    INTO :NEW.PRODUCT_TIME_NUMBER
--    FROM DUAL; 
--END;
--/



COMMIT;


DESC PRODUCT_TIME;

